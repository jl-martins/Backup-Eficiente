%Preâmbulo
\documentclass[a4paper,12pt,titlepage,portuguese]{article}

\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{hyperref,textgreek}

\makeatletter
  \newcommand{\nop}[1]{\Hy@raisedlink{\hypertarget{#1}{}}}
\makeatother

\title{Relatório do Trabalho Prático de Sistemas Operativos\\[1cm]\large{\textbf{Backup-Eficiente}}\\\large{2015/2016-MIEI}}

\author{João Martins (A68646) \\João Pereira (A75273)}

\date{\today}
%Fim do Preâmbulo
\begin{document}

\pagenumbering{Alph}
\maketitle

\begin{abstract}
\pagenumbering{gobble}
O trabalho desenvolvido consiste num sistema de cópias de segurança de ficheiros escrito em \texttt{C}, que segue uma arquitetura cliente/servidor e suporta operações de \emph{backup} e restauro de ficheiros\/diretorias, bem como de remoção de ficheiros de cópia de segurança e \emph{garbage collection}. Todas as operações são executadas num programa servidor, a pedido de um ou mais programas cliente que poderão estar a executar em simultâneo, desde que estejam na mesma conta de utilizador que o servidor. Cada instância do programa cliente (\texttt{sobucli}) envia um comando para o servidor (\texttt{sobusrv}) através de um fifo (\emph{named pipe}) situado na raiz do backup. O sucesso/insucesso a executar um pedido de um cliente é indicado pelo servidor através dos sinais \texttt{SIGUSR1} (sucesso) e \texttt{SIGUSR2} (insucesso).

\end{abstract}

\pagenumbering{roman}
\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Configuração}

\subsection{Instruções}

\subsubsection{Instalação}

Para instalar o sistema de cópias de segurança:
	\begin{enumerate}
		\item Descomprimir o ficheiro \texttt{SO\_Grupo3.zip};
		\item Invocar o comando \texttt{make install} e introduzir as credenciais do \emph{superuser} quando pedidas;
	\end{enumerate}
\textbf{Nota:} é necessário introduzir as credenciais do \emph{superuser} para mover os executáveis para a diretoria \texttt{/usr/bin}, permitindo assim que seja possível invocar \texttt{sobucli} e \texttt{sobusrv} sem especificar o caminho absoluto dos executáveis.

\subsubsection{Desinstalação}

Para desinstalar o sistema de cópias de segurança:
	\begin{enumerate}
		\item Invocar o comando \texttt{make unninstall} na diretoria que tem a \texttt{Makefile} do projeto e introduzir as credenciais do \emph{superuser} quando pedidas;
		\item Optar por apagar ou não apagar os dados dos \emph{backups} antigos quando questionado;
	\end{enumerate}
\textbf{Nota:} as credenciais de \emph{superuser} são necessárias apenas para remover \texttt{sobucli} e \texttt{sobusrv} da diretoria \texttt{/usr/bin}.

\newpage

\subsection{Makefile e scripts}

\subsubsection{Makefile}
Apresenta-se a \texttt{Makefile} utilizada pelo grupo para gerar os executáveis, invocar os scripts de instalação/desinstalação (\texttt{make install} e \texttt{make unninstall}, respetivamente) e gerar o relatório (\texttt{make relatorio}):
	\begin{verbatim}
	CFLAGS = -Wall -Wextra -O2
	TARGET_ARCH = -march=native

	all: sobucli sobusrv

	.PHONY: all install unninstall relatorio clean

	install: all
		bash install.sh

	unninstall:
		bash unninstall.sh

	relatorio:
		cd Relatorio; pdflatex relatorio.tex

	debug: CFLAGS = -Wall -Wextra -g
	debug: all

	sobucli: sobucli.o readln.o comando.o comando.h
		$(LINK.c) $^ $(OUTPUT_OPTION)

	sobusrv: sobusrv.o comando.o
		$(LINK.c) $^ $(OUTPUT_OPTION)

	clean:
		$(RM) sobucli sobusrv
		$(RM) *.o
		$(RM) Relatorio/relatorio.{aux,log,out,toc}
	\end{verbatim}

\newpage
\subsubsection{install.sh}
O \emph{script} de instalação \texttt{install.sh}:
	\begin{enumerate}
		\item Cria a diretoria \texttt{\$HOME/.Backup/} (raiz do \emph{backup});
		\item Cria as pastas \texttt{data} e \texttt{metadata} na raiz do \emph{backup};
		\item Invoca \texttt{mkfifo} para criar, na raiz do \emph{backup}, o \texttt{fifo} o utilizado para os clientes enviarem comandos ao servidor as pastas \texttt{data} e \texttt{metadata};
		\item Move os executáveis \texttt{sobucli} e \texttt{sobusrv} para a diretoria \texttt{/usr/bin};
	\end{enumerate}
\textbf{Nota:} se algumas das pastas/ficheiros a criar já existir, a instalação prossegue sem causar quaisquer problemas. 
\\Código de \texttt{install.sh}:
	\begin{verbatim}
	mkdir -p $HOME/.Backup/data
	mkdir -p $HOME/.Backup/metadata
	if [ ! -p $HOME/.Backup/fifo ]; then
		mkfifo $HOME/.Backup/fifo -m 0666
	fi
	sudo mv -t /usr/bin sobucli sobusrv
	\end{verbatim}

\subsubsection{unninstall.sh}
O script de desinstalação:
	\begin{enumerate}
		\item Remove o \emph{log} de erros de \texttt{sobusrv};
		\item Remove \texttt{sobucli} e \texttt{sobusrv} de \texttt{/usr/bin};
		\item Pergunta ao utilizador se pretende remover os dados dos seus \emph{backups} e, caso o utilizador pretenda fazê-lo, remove a pasta \texttt{\$HOME/.Backup} e todos os seus conteúdos;
	\end{enumerate}
Código de \texttt{unninstall.sh}:
	\begin{verbatim}
	rm -f  $HOME/.Backup/fifo $HOME/.Backup/log.txt

	sudo rm -f  /usr/bin/sobucli /usr/bin/sobusrv 
	echo "Deseja apagar os dados de backups antigos?"
	select sn in "Sim" "Nao"; do
	    case $sn in
	        Sim ) rm -rf $HOME/.Backup; break;;
	        Nao ) exit;;
	    esac
	done
	\end{verbatim}

\section{Estruturação das diretorias do backup}

\subsection{metadata}
Em \texttt{metadata} temos, para todo o ficheiro \texttt{f} salvaguardado com o comando \texttt{backup}:
	\begin{itemize}
		\item Um \emph{link} simbólico para o conteúdo original comprimido de \texttt{f}. O nome deste \emph{link} é igual ao do ficheiro original;
		\item Um ficheiro de texto com uma única linha que indica o caminho absoluto original do ficheiro \texttt{f}, permitindo-nos assim a recuperação do ficheiro para o seu local original, aquando da invocação do comando \texttt{restore}. O nome deste ficheiro de texto não pode ser igual ao do \emph{link} simbólico referido em \texttt{1.}, pelo que optamos por, partindo do nome do \emph{link} simbólico, acrescentar o caratére \texttt{Unit Separator} (\texttt{ASCII} 31) ao início do nome do ficheiro de texto.
	\end{itemize}

\subsection{data}
A diretoria \texttt{/data/}, situada na raiz do \emph{backup}, armazena os ficheiros salvaguardados com o comando \texttt{backup} num ficheiro comprimido com o programa \texttt{.gzip}. O nome do ficheiro comprimido é o \texttt{digest} do conteúdo do ficheiro original (produzido pelo programa \texttt{sha1sum}), seguido de \texttt{.gz}.\\\\\textbf{Nota:} se o utilizador tiver vários ficheiros com o mesmo conteúdo e nomes diferentes, apenas guardamos o conteúdo comprimido do primeiro desses ficheiros a ser enviado para \emph{backup}. Para cada um dos restantes ficheiros criamos somente um \emph{link} em \texttt{metadata} que aponta para o conteúdo comprimido já existente em \texttt{/data} e armazenamos o caminho original de cada um deles, evitando assim a duplicação de dados.

\section{Operações suportadas}

O programa desenvolvido suporta operações de:

	\begin{itemize}
		\item \emph{Backup} de ficheiros\/diretorias;
		\item Recuperação de ficheiros\/diretorias ;
		\item Remoção de ficheiros de cópia de segurança;
		\item \emph{Garbage collection}, i.e.: remoção de todos os ficheiros da pasta \texttt{/data} que não têm qualquer link simbólico da pasta \texttt{/metadata} que os referencie;
	\end{itemize}

\subsection{backup}

Ao invocar o comando \texttt{sobucli backup}, o utilizador pode optar especificar tanto caminhos absolutos como caminhos relativos nos ficheiros passados como argumentos para o comando, uma vez que o programa \texttt{sobucli} tem a capacidade de expandir caminhos relativos para caminhos absolutos antes de enviar um comando para o servidor.\\\\\textbf{Nota:} de forma a seguir o esquema de \emph{links} simbólicos apresentado na página 3 do enunciado (antes da secção de \texttt{Valorização}), optamos por atribuir a cada \emph{link} simbólico o nome do ficheiro original a que este diz respeito (sem guardar o caminho absoluto desse ficheiro no nome do \emph{link}). Este tipo de abordagem leva a que não seja possível fazer \emph{backup} de 2 ficheiros que estão em diretorias diferentes e têm o mesmo nome. Uma forma de contornar esta limitação seria guardar no nome de cada \emph{link} o caminho absoluto do ficheiro comprimido para que este aponta. A impossibilidade de utilizar \'/\' no nome do \emph{link} poderia ser contornada substituindo \'/\' por um caratére que possa ser utilizado no nome de ficheiros e que praticamente nunca seja introduzido pela maioria dos utilizadores, como por exemplo o caratére \texttt{Unit Separator} (\texttt{ASCII} 31). Outra solução seria ter em \texttt{/metadata} cada uma das pastas constituintes do caminho dos ficheiros de que se fez \emph{backup} (replicando de certa forma a hierarquia do sistema de ficheiros). A título de exemplo, suponhamos que é pedido o \emph{backup} de 2 ficheiros de nome igual e conteúdo diferente, cujos caminhos são \texttt{/home/user/Desktop/a.pdf} e \texttt{/home/user/Documents/a.pdf}. Na abordagem referida, teríamos em \texttt{/metadata} os caminhos \texttt{/home/joao/Desktop/a.pdf} e \texttt{/home/joao/Documents/a.pdf}, em que o último elemento de cada um desses caminhos é um \emph{link} simbólico para o conteúdo comprimido do respetivo ficheiro original.

\subsection{restore}

Na invocação do comando \texttt{sobucli restore}, o utilizador deverá introduzir apenas o nome dos ficheiros que pretende restaurar para o seu caminho original. Note-se que não há qualquer ambiguidade porque, tal como foi referido na subsecção anterior, depois de o utilizador fazer \emph{backup} de um dado ficheiro, não poderá fazer \emph{backup} de outros ficheiros com o mesmo nome que o primeiro. É também importante notar que o comando \texttt{sobucli restore} serve para restaurar ficheiros e não diretorias. Para restaurar diretorias o utilizador deverá invocar o comando \texttt{sobucli frestore} (\emph{folder restore}).

\textbf{Nota:} Os comandos \texttt{sobucli backup} e \texttt{sobucli restore} não deverão ser executados em simultâneo, uma vez que a ordem pela qual chegam ao servidor não é necessáriamente a ordem pela qual são introduzidos e o resultado obtido depende da ordem de execução dos comandos. Assim, se o utilizador optar por executar \texttt{sobucli backup} e \texttt{sobucli restore} em simultâneo, o comportamento é indefinido.

\subsection{frestore}

O comando \texttt{sobucli frestore} (\emph{folder restore}) permite restaurar diretorias. Como várias diretorias diferentes podem ter o mesmo nome, é necessário especificar em cada um dos argumentos de \texttt{sobucli frestore}, o caminho absoluto das diretorias que se pretende restaurar.

\subsection{delete}

O comando \texttt{sobucli delete} recebe uma lista de um ou mais \underline{ficheiros} e apaga as referências que possam existir em \texttt{metadata\/} para cada um desses ficheiros. Se não existir nenhum \emph{link} para um dado ficheiro passado para o comando \texttt{delete}, consideramos que o objetivo de apagar esse ficheiro é trivialmente cumprido, pelo que se considera que \texttt{delete} teve sucesso.

\subsection{garbace collector (gc)}

O comando \texttt{sobucli gc} não recebe quaisquer argumentos e é responsável por eliminar todos os ficheiros da diretoria \texttt{data\/} que não estão a ser usados por nenhuma entrada em \texttt{\/metadata}. Se o utilizador passar argumentos adicionais para \texttt{sobucli gc}, é impressa uma mensagem de erro a indicar que \texttt{sobucli gc} não recebe quaisquer argumentos.

\section{struct comando}

De forma a agrupar numa única estrutura os vários dados que o servidor necessita para executar um determinado comando, o grupo optou por definir a \texttt{struct command}, permitindo assim que a informação de cada comando enviado para servidor tenha um número fixo de bytes (dado por \texttt{sizeof(struct command)}), o que facilita o acesso à mesma. 

Cada comando que é enviado para \texttt{sobusrv} tem 3 campos:

	\begin{itemize}
		\item \texttt{pid} do processo que enviou o comando, de forma a que o servidor possa enviar o sinal que indica conclusão de uma operação ou erro ao processo que ficou encarregue por pedir essa operação;
		\item Caminho relativo\/absoluto dos ficheiros a utilizar no comando a executar. No caso do comando \texttt{sobucli gc} este campo é uma \emph{String} começada por \'\\0\';
		\item Abreviatura do comando a realizar (1º caratére do nome do comando); 
	\end{itemize}

	Segue-se a declaração da \texttt{struct comando}:

	\begin{verbatim}
	struct comando{
		pid_t pid;
		char filepath[MAX_PATH];
		char codigoComando;
	};
	\end{verbatim}
, onde \texttt{MAX\_PATH} é uma macro definida em \texttt{comando.h} como 2048.
\\\\\textbf{Nota:} \underline{não confundir} a macro \texttt{MAX\_PATH}, definida pelo grupo, com a macro \texttt{PATH\_MAX}, definida em \texttt{Linux} e \texttt{Mac OSX}. \texttt{PATH\_MAX} está definida na maioria dos sistemas operativos \texttt{Linux} como 4096, devido a este ser o tamanho máximo para o qual há garantia que uma invocação da \emph{system call} \texttt{write()} é atómica. A razão para o grupo limitar o tamanho máximo de cada \emph{path} a 2048 caratéres \texttt{ASCII} prende-se com a necessidade de, em cada comando enviado para o servidor, enviarmos informação adicional como o \emph{pid} do processo que enviou o comando e a abreviatura desse comando. Se o tamanho máximo de cada caminho fosse 4096 caratéres, a escrita adicional da abreviatura do comando e do \texttt{pid} do processo que o enviou iriam implicar um \texttt{write} de um número superior a 4096 caratéres, pelo que não teríamos garantias relativamente à atomicidade de cada escrita no \texttt{fifo} usado para comunicar como o servidor. Se as escritas no \texttt{fifo} não fossem atómicas, ao existir mais do que um processo \texttt{sobucli} a escrever no \emph{named pipe}, correríamos o risco de enviar partes de comandos diferentes intercaladas umas com as outras, corrompendo as mensagens que se pretende transmitir.

De forma a abstrair os detalhes de implementação da \texttt{struct comando} e ao mesmo tempo proteger os conteúdos da mesma, o grupo definiu o tipo \texttt{Comando} no ficheiro \texttt{comando.h} da seguinte forma:

	\begin{verbatim}
	typedef struct comando * Comando;
	\end{verbatim}

A criação\/destruição de comandos, bem como a obtenção cada um dos campos da \texttt{struct comando} é realizada com as seguintes funções:

	\begin{verbatim}
	/* Aloca memória para um comando. */
	Comando aloca_comando();
	/* 
	 * Aloca memória para um comando e inicializa-o com o o código de comando
	 * passado como 1º argumento e com o caminho de ficheiro passado como 2º
	 * argumento. O pid associado ao comando é o do processo que chama a função.
	 */
	Comando aloca_inicializa_comando(char codigoComando, char * caminho_ficheiro);
	/* Devolve o pid do processo que enviou o comando passado como argumento. */
	pid_t get_pid_comando(Comando cmd);
	/* Devolve o caminho do ficheiro associado ao comando passado como argumento. */
	char * get_filepath(Comando cmd);
	/* Devolve o código do comando passado como argumento. */
	char get_codigoComando(Comando cmd);
	/* Devolve o número de bytes que um comando ocupa em memória. */
	ssize_t tamanhoComando();
	\end{verbatim}

\section{sobucli}

\subsection{Utilização}

\texttt{sobucli} - envia para \texttt{sobusrv} comandos de cópia, restauro e remoção de ficheiros, bem como de \emph{garbage collection}.
\\\\\texttt{sobucli comando [ficheiros]...}

\subsection{Implementação}

\subsubsection{Validação de comandos}

O envio de comandos que sabemos logo à partida que são inválidos iria ocupar desnecessariamente \texttt{sobusrv}, pelo que optamos por realizar logo à partida todas as validações que o cliente possa fazer. Assim, mal uma instância de \texttt{sobucli} começa a executar, verificamos:

	\begin{enumerate}
		\item se \texttt{argc} é superior a 1 (i.e.: se o utilizador introduziu um comando);
		\item se, nos casos em que o comando (\texttt{argv[1]}) é \texttt{gc}, \texttt{argc} é igual a 2 (isto porque \texttt{gc} não recebe quaisquer argumentos);
		\item se, nos casos em que o comando introduzido é \texttt{backup}, \texttt{restore}, \texttt{delete} ou \texttt{frestore}, temos \texttt{argc >= 3}, i.e.: se foram especificados ficheiros à direita do comando introduzido;
	\end{enumerate}
Se alguma das condições acima referidas falhar, o programa cliente imprime no \texttt{stderr} a mensagem de erro adequada à pré-condição que falhou e termina a execução com \texttt{\_exit(1)} sem chegar a abrir o \texttt{fifo} para escrita.

\subsubsection{Abreviaturas de comandos} \label{Abreviaturas de comandos}

Atentando no facto de todos os comandos implementados começarem com uma inicial diferente, o grupo optou por abreviar cada comando à sua 1ª letra, tendo para esse fim criado a função \texttt{get\_cmd\_abbrev}:

	\begin{verbatim}
	/* 
 	 * Valida o comando introduzido com base em argc e 
 	 * argv e, se este for válido, devolve uma abreviatura 
 	 * do mesmo. A abreviatura devolvida nao é mais do que
 	 * a 1ª letra do comando. Se o comando ou o número de
 	 * argumentos forem inválidos, imprime uma mensagem de erro 
 	 * no stderr e  devolve o carater '\0'.
 	 */
	char get_cmd_abbrev(int argc, char* argv[]);
	\end{verbatim}
\texttt{get\_cmd\_abbrev} realiza cada uma das validações listadas em \ref{Abreviaturas de comandos} e se alguma falhar, apresenta uma mensagem de erro de acordo com a condição que falhou \texttt{stderr} e devolve \'\\0\'. Se nenhuma das validações falhar, é devolvido o primeiro caratére do comando introduzido. 

A utilização de abreviaturas de comandos permite que sempre que pretendemos testar qual é o comando a ser executado não tenhamos que invocar a função \texttt{strcmp}.

\subsubsection{Variáveis globais ao módulo sobucli}

No início de \texttt{sobucli.c} temos a declaração das seguintes variáveis globais:

	\begin{verbatim}
	static char cmd_abbrev = '\0';
	static char* last_file = NULL;
	static int nchild;
	\end{verbatim}
\texttt{cmd\_abbrev} guarda a abreviatura do comando que está a ser executado, ou \texttt{\'\\0\'} se ainda não foi lido um comando válido. Esta variável é global para que no interior do \texttt{sighandler} invocado para tratar \texttt{SIGUSR1} e \texttt{SIGUSR2} tenhamos informação relativamente ao comando que foi executado e possamos imprimir a mensagem de sucesso/erro adequada. 

\texttt{last\_file} é um apontador para o caminho absoluto\/relativo do último ficheiro tratado numa determinada operação. Esta variável também é global para que possa ser acedida \texttt{sighandler} de \texttt{SIGUSR1} e \texttt{SIGUSR2} e possamos imprimir o nome e/ou o caminho do ficheiro utilizado num dado pedido.

\texttt{nchild} permite controlar o número de processos filhos criado pelo programa cliente, uma vez que, para cada ficheiro da lista de ficheiros passada nos comandos \texttt{backup}, \texttt{restore} e \texttt{delete}, criamos um processo filho que fica responsável por enviar o seu \texttt{pid}, o comando a executar e o ficheiro\/caminho absoluto a usar na operação. Embora não tenha sido imposto um limite ao número de processos filho que uma instância de \texttt{sobucli} poderá criar, o grupo optou por impor um limite de 5 processos filho em cada instante. A forma como o número de processos filho é controlado será apresentada com mais detalhe na secção \ref{Envio de comandos}.

\subsubsection{Construção do caminho da fifo}

O caminho absoluto do \texttt{fifo} é obtido da seguinte forma:
	\begin{verbatim}
		char backup_path[MAX_PATH];
		(...)
		strcpy(backup_path, getenv("HOME"));
		strcat(backup_path, "/.Backup");
		strcat(backup_path, "/fifo");
	\end{verbatim}

\subsubsection{Caminhos absolutos dos argumentos}

O servidor (\texttt{sobusrv}) necessita de ter conhecimento do caminho absoluto dos ficheiros de que o cliente pretende fazer \emph{backup} para que seja possível restaurá-los para o seu caminho original. Assim, mesmo que o utilizador invoque o comando \texttt{sobucli backup} com um ou mais ficheiros para os quais especifica apenas um caminho relativo à sua \emph{working directory}, o programa \texttt{sobucli} trata de expandir cada um desses caminhos relativos para o respetivo caminho absoluto, através da invocação da função \texttt{realpath}, importada da \texttt{stdlib}. A utilização de \texttt{realpath} possibilita também a realização de verificações adicionais, uma vez que se o utilizador especificar um caminho inválido \texttt{realpath} devolve \texttt{NULL}, permitindo que o cliente apresente uma mensagem de erro e passe para o próximo argumento de \texttt{backup} sem ter que \"incomodar\" o servidor.

Sempre que \texttt{realpath} expande com sucesso o caminho absoluto de um ficheiro passado como argumento para o comando de \texttt{backup}, testamos se o caminho absoluto obtido diz respeito a um ficheiro ou a uma diretoria, recorrendo para isso às funções \texttt{is\_file} e \texttt{is\_dir}, definidas com o auxílio da \emph{system call} \texttt{stat} da seguinte forma:

	\begin{verbatim}
	int is_file(char* path){
		struct stat sb;

		if(stat(path, &sb) == -1){
			perror("stat");
			return 0;
		}
		return S_ISREG(sb.st_mode);
	}

	int is_dir(char* path){
		struct stat sb;

		if(stat(path, &sb) == -1){
			perror("stat");
			return 0;
		}
		return S_ISDIR(sb.st_mode);
	}
	\end{verbatim}


\subsubsection{Envio de comandos} \label{Envio de comandos}

Se os argumentos de \texttt{sobucli} fossem enviados numa única linha para \texttt{sobusrv} haveria o risco de o número de bytes enviados exceder \texttt{PIPE\_BUF} e nesse caso deixaríamos de ter garantias relativamente à atomicidade das escritas, levando a que quando são executadas várias instâncias de \texttt{sobucli} concorrentemente, partes de comandos de diferentes fossem intercaladas umas com as outras. Além disso, quando o servidor responde com \texttt{SIGUSR1} ou \texttt{SIGUSR2} de forma a indicar o sucesso ou insucesso de uma operação também é necessário saber a que operação este se refere e se um único processo enviasse todos os argumentos recebidos por \texttt{sobucli} numa única escrita, dificilmente se saberia a que ficheiro se refere cada um dos sinais recebidos. Assim, de forma a garantirmos a atomicidade das escritas e ao mesmo tempo termos uma forma de saber a que ficheiro diz respeito cada um dos sinais enviados por \texttt{sobusrv} (nas várias operações que não \texttt{gc}) optamos por, para cada ficheiro dos argumentos de um dado comando, criar um processo filho de \texttt{sobucli} que fica encarregue de enviar o comando que diz respeito a esse ficheiro. A título de exemplo, se \texttt{sobucli} fosse invocado da seguinte forma \texttt{sobucli backup a.pdf b.pdf}, o processo original de \texttt{sobucli} iria criar 2 processos filho, um para enviar uma \texttt{struct Comando} que tem o seu \texttt{pid}, a abreviatura do comando (\'b\') e o caminho absoluto do ficheiro \texttt{a.pdf} e outro para enviar outra \texttt{struct Comando} com o seu \texttt{pid}, o comando \'b\' e o caminho absoluto de \texttt{b.pdf}. Assim, os comandos de \emph{backup} de um dado ficheiro, bem como \texttt{restore}, \texttt{frestore} e \texttt{delete} são enviados com através a função \texttt{send\_cmd}, definida do seguinte modo:
	
	\begin{verbatim}
	void send_cmd(int fifo_fd, char* arg_path, char* full_path){
		Comando cmd;

		if(nchild >= 5){ /* limita o número de processos filho */
			wait(NULL);
			--nchild;
		}

		switch(fork()){
			case 0: /* processo filho */
				last_file = (arg_path != NULL) ? arg_path : full_path;
				if(full_path)
					cmd = aloca_inicializa_comando(cmd_abbrev, full_path);
				else
					cmd = aloca_inicializa_comando(cmd_abbrev, arg_path);
				
				if(write(fifo_fd, cmd, tamanhoComando()) != tamanhoComando())
					PERROR_AND_EXIT("write")
				
				close(fifo_fd);
				free(cmd);
				pause();
				_exit(1);
			case -1:
				perror("fork");
				_exit(1);
		}
	}
	\end{verbatim}

\texttt{fifo\_fd} é o descritor do \texttt{fifo} por onde o comando será enviado, \texttt{arg\_path} é o caminho do ficheiro, tal como surge nos argumentos de \texttt{sobucli} e \texttt{full\_path} é o caminho absoluto do ficheiro. No caso dos comandos de \texttt{backup} a função \texttt{send\_cmd} é sempre invocada com o \texttt{full\_path} do ficheiro a enviar para o servidor e \texttt{arg\_path} a \texttt{NULL}. No caso de \texttt{gc},  \texttt{arg\_path} é a string vazia ``'', de forma a indicar que o comando não tem argumentos. Para os restantes comandos é passado o \texttt{arg\_path} e \texttt{full\_path} é passado a \texttt{NULL}.

Também é importante notar que no início de cada invocação de \texttt{send\_cmd} verificamos o valor do variável global \texttt{nchild} e se este for maior ou igual a 5, o processo pai espera por um dos seus filhos antes de prosseguir a execução e fazer um \texttt{fork()}.

Chegando ao \texttt{switch}, o processo pai faz \texttt{fork()} e o processo filho guarda na variável global \texttt{last\_file} o caminho absoluto ou relativo (dependendo do comando a executar) do ficheiro a que o comando diz respeito (no caso de \texttt{gc} não é um ficheiro, mas sim uma \emph{String} vazia tal como já foi referido). Posto isto, se o processo \texttt{full\_path} for diferente de \texttt{NULL}, o processo filho cria um \texttt{Comando} com a variável global \texttt{cmd\_abbrev} e com o argumento \texttt{full\_path}, se não cria um comando com \texttt{cmd\_abbrev} e \texttt{arg\_path}. Em seguida, este comando é escrito no \texttt{fifo} e em caso de sucesso, o processo filho fecha o descritor de escrita do \texttt{fifo}, liberta \texttt{cmd} e invoca \texttt{pause()} para aguardar pelo sinal do servidor a indicar conclusão ou erros na operação.

\subsubsection{Backup de diretorias}

Sempre que num comando de \emph{backup} um caminho absoluto remete para uma diretoria, executamos o programa \texttt{find}para obter os caminhos de cada ums dos ficheiros contidos nas subdiretorias da diretorias indicada e invocamos \texttt{send\_cmd()} com cada um dos ficheiros obtidos.

Como uma execução do programa \texttt{find} pode produzir uma grande quantidade de linhas, o grupo optou por definir a seguinte função:

	\begin{verbatim}
	int find(const char* path){
		pid_t p;
		int pipefd[2];
		int out_fd, status;

		if(pipe(pipefd) == -1)
			return -1;

		p = fork();
		if(p == 0){ /* filho */
			close(pipefd[0]);
			if(dup2(pipefd[1], 1) == -1)
				_exit(1);
			else
				close(pipefd[1]);

			execlp("find", "find", path, NULL);
			_exit(1);
		}
		else if(p == -1){
			close(pipefd[0]); close(pipefd[1]); out_fd = -1;
		}
		else{ /* pai */
			close(pipefd[1]);
			p = wait(&status);
			if(p != -1 && WIFEXITED(status) && WEXITSTATUS(status) == 0)
				out_fd = pipefd[0];
			else{ /* algo correu mal no processo filho */
				close(pipefd[0]);
				out_fd = -1;
			}
		}
		return out_fd;
	}
	\end{verbatim}
Tal como pode ser observado, o processo que invoca a função \texttt{find()} cria um pipe anónimo e faz \texttt{fork()}. Se o \texttt{fork()} tiver sucesso, o processo filho fecha o descritor de leitura do \emph{pipe} e redireciona o \texttt{standar output} para a ponta de escrita do \emph{pipe}. Uma vez feito este redirecionamento, o processo filho invoca a \emph{system call} \texttt{execl()} para executar a função \texttt{find} com o \emph{path} passado. Já o processo pai fecha a ponta de escrita do \emph{pipe} e espera pelo filho. Se o filho tiver terminado a sua execução com sucesso, o processo pai guarda em \texttt{out\_fd} o descritor de leitura do \emph{pipe} e devolve-o para a função chamadora, para que seja possível obter cada uma das linhas produzidas por \texttt{find}.

Para que a leitura de cada uma das linhas produzidas pela função \texttt{find} seja eficiente, optamos por usar a função \texttt{int readln(struct buffer\_t *bufer, void **buf)} baseada no exercício 7. do guião 1. Nesta versão de \texttt{readln()}, cada invocação de \texttt{read} lê até 4096 bytes para um \emph{buffer} interno a \texttt{struct buffer\_t} e em cada chamada de \texttt{readln()} é escrita uma linha no buffer apontado por \texttt{buf}.

Como o programa \texttt{find} também pode incluir diretorias no seu resultado, testamos para cada linha lida, se esta é um ficheiro com a função \texttt{is\_file} (já apresentada acima) e se for, invocamos \texttt{send\_cmd()} para que o servidor faça \emph{backup} do ficheiro encontrado na diretoria de que estamos a fazer \emph{backup} ou nas suas subdiretorias. 

\subsubsection{Recepção de sinais}

Os sinais \texttt{SIGUSR1} e \texttt{SIGUSR2}, enviados pelo servidor para indicar conclusão e insucesso de uma operação, respetivamente, são armados na função \texttt{main} através das invocaçõs \texttt{signal(SIGUSR1, sighandler)} e
\texttt{signal(SIGUSR2, sighandler)}, antes de qualquer comando ser enviado. Assim, sempre que \texttt{send\_cmd()} é invocado, o processo filho que envia o comando já tem \texttt{SIGUSR1} e \texttt{SIGUSR2} armados e quando recebe um desses sinais salta para a função \texttt{sighandler}. 

Em \texttt{sighandler}, o processo sinalizado verifica a variável global \texttt{cmd\_abbrev} para testar qual foi o comando que executou e acede ainda à variável global \texttt{last\_file} para obter o nome\/caminho do ficheiro usado no último comando. Se o sinal recebido for \texttt{SIGUSR1} (sucesso), o processo filho imprime a mensagem de sucesso adequada ao seu comando que enviou para o servidor e invoca \texttt{\_exit(0)}, se não, imprime uma mensagem de erro relativa ao comando enviado e invoca \texttt{\_exit(1)}.

\section{sobusrv}

\subsection{Utilização}

O servidor é iniciado introduzindo apenas \texttt{sobusrv} numa shell. Este comando ignora quaisquer flags e argumentos passados e fica a correr em segundo plano, à espera que um ou mais clientes lhe enviem comandos.
\subsection{Implementação}
Quando o servidor é iniciado, é feita a inicialiazação das variáveis com os caminhos de ficheiros que serão utilizados em todo o programa:
	\begin{enumerate}
		\item backup\_path - \$HOME/.Backup/
		\item metadata\_path -  \$HOME/.Backup/metadata/
		\item data\_path - \$HOME/.Backup/data/   
		\item fifo\_path - \$HOME/.Backup/fifo
		\item logfile\_path - \$HOME/.Backup/log.txt
	\end{enumerate}
	
Imediatamente a seguir, é aberto o ficheiro \texttt{log.txt} para registar os erros do servidor. O \texttt{stderr} é redirecionado para o \texttt{log.txt} através da system call \texttt{dup2}.
Este redirecionamento funcionará para todos os subprocessos do processo inicial, de forma a que todos eles possam registar os seus erros. 

Para podermos ``desocupar'' a \emph{shell}, i.e. executar o processo em \emph{background}, fazemos um fork em que o pai termina e o filho continua a executar. Posto isto, o programa executa ainda mais um fork em que o filho abre a ponta de escrita do fifo que se encontra na raíz do \emph{backup} e depois invoca a \emph{sytem call} \texttt{pause()} de forma a ficar adormecido. Se não fizessémos este \texttt{fork()}, quando todos os processos fechassem a ponta de escrita do fifo (por ex: quando todos os comandos enviados pelo \texttt{sobucli} terminam), o processo ``principal'' do \texttt{sobusrv} que gere a crição de outros processos iria entrar em espera ativa porque não ia bloquear nos \texttt{reads} da FIFO, resultando numa performance deplorável. 

O processo pai continua a execução e cria 5 processos em que cada um lê um comando da FIFO e começa a sua execução através da invocação da função \texttt{setupComand()}. O processo pai fica à espera que os filhos terminem e sempre que algum morre, é criado um novo processo que lê um comando da FIFO. Desta forma, asseguramos que, no máximo, temos 5 operações em simultâneo uma vez que só lemos um novo comando quando outro termina. 

A função \texttt{setupComando()}, como foi dito anteriormente, lê um comando do FIFO e começa a sua execução. Mais detalhadamente, é lida uma \texttt{struct comando} do FIFO e se a leitura tiver sido bem sucedida, é executado o comando nela guardado através da função \texttt{execComando()}. Finda a execução do comando, é enviado para o processo cliente que escreveu o Comando na FIFO o sinal SIGUSR1 se o comando tiver sido executado com sucesso e SIGUSR2 se tiver havido algum erro.

A função \texttt{execComando()} serve unicamente para invocar a operação correta(\texttt{backup()}, \texttt{restore()}, \texttt{frestore}, \texttt{gc()} ou \texttt{delete()}) com os argumentos necessários, se for o caso.

As operações suportadas estão implementadas, através de funções com o nome respetivo, da seguinte maneira:

\subsubsection{backup(char * filepath)}

Dado um caminho absoluto de um ficheiro, calculamos o \texttt{sha1sum} através da função \texttt{sha1sum()} e inserimos um \texttt{symlink} com o nome do ficheiro a guardar que aponta para \texttt{data/sum.gz}, em que \texttt{sum} é o resultado da função \texttt{sha1sum()}. Se já existir um \texttt{symlink} com esse nome na \texttt{data}, o programa termina: definimos que para esses casos vamos manter o 1º ficheiro guardado. Caso contrário, escrevemos num ficheiro cujo nome é o nome do ficheiro a guardar iniciado por um caracter não-imprimível (de forma a evitar colisões de nomes). Esse ficheiro contém o \emph{path} completo para o ficheiro que foi guardado. Por fim, verificamos se exite na pasta \texttt{data} um arquivo cujo nome é o \texttt{sha1sum} do ficheiro sufixado de ``.gz'' e se não existir, fazemos o zip invocando a função \texttt{zipFile}.

\subsubsection{restore(char * filename)}

Dado o nome(e não o caminho absoluto) de um ficheiro, verificamos se esse ficheiro já foi guardado, bastando para tal ver se existe um ficheiro com o nome do ficheiro a restaurar na pasta metadata (no caso de existir, corresponde ao symlink para o ficheiro nos dados). Se o ficheiro não tiver sido guardado, o programa termina. Caso contrário, tentamos abrir o ficheiro que contém o path original do ficheiro e, em caso de sucesso, fazemos o unzip para esse local do ficheiro 
armazenado em data. Note-se que antes de restaurarmos o ficheiro, reconstruimos o path até ao local para onde o ficheiro vai ser restaurado fazendo um fork e no filho:
\begin{verbatim}
execlp("mkdir", "mkdir", "-p", path, NULL);
\end{verbatim}

O pai faz um \texttt{wait} para assegurar que o caminho é criado antes de ele tentar restaurar o ficheiro.

\subsubsection{delete(char * filename)}

Dado o nome de um ficheiro (e não o seu caminho), verifica se existe um ficheiro com esse nome na pasta \texttt{metadata}.Se não existir, então é devolvido 0 a indicar sucesso - se um ficheiro não existe, o objetivo de apagar o ficheiro é trivialmente alcançado. Caso contrário, tentamos apagar o ficheiro que contem o path e o symlink através da \texttt{unlink}. Se não conseguirmos apagar um desses ficheiros, é devolvido 1 a sinalizar a ocorrência de um erro. Caso contrário, é devolvido 0. Esta função não apaga conteúdo na pasta \texttt{data}. Esse trabalho é deixado a cargo do comando \texttt{gc}.

\subsubsection{gc()}

Para cada ficheiro na pasta backup, se existir algum \texttt{symlink} para o mesmo, mantemos o ficheiro. Caso contrário, apagamos esse ficheiro. Para percorrer os ficheiros da pasta de backup utilizamos a função \texttt{opendir()} e \texttt{readdir()}. Para verificarmos se um ficheiro tem algum symlink na pasta \texttt{metadata} usamos a função \texttt{temLink()}, que dado o caminho absoluto para um ficheiro, devolve 1 se existe um \texttt{symlink} em \texttt{metadata} para ele e 0 caso contrário.

\subsubsection{frestore(char * absolute\_path\_folder)}

Dado um caminho absoluto de uma pasta, restaura a pasta e todos os ficheiros dessa pasta. 
O programa percorre todos os ficheiros guardados na pasta \texttt{metadata} e, sempre que encontra um ficheiro de texto que guarda o path de um ficheiro guardado (i.e. sempre que encontra um ficheiro cujo nome começa pelo caracter não imprimivel que definimos), lê o conteúdo desse ficheiro (que corresponde ao caminho de um ficheiro salvaguardado) para um buffer e se o caminho absoluto da pasta passado como argumento for um prefixo do caminho que está no buffer (verificado com a função \texttt{strstr}, quer dizer que esse ficheiro estava na pasta que pretendemos restaurar e por isso restauramos o ficheiro com a restore.

\subsubsection{ sha1sum(char * filepath) - função auxiliar}

Dado o caminho absoluto para um ficheiro, devolve uma string com o seu sha1sum. Esta função cria um pipe anónimo e depois faz um \texttt{fork}. No processo filho, fecha-se a ponta de leitura do pipe e depois, através do \texttt{dup}, redireciona o \texttt{stdout} para o pipe criado. A seguir, invoca a \texttt{execlp} de forma a executar o programa \texttt{sha1sum} e escreve o seu resultado no pipe anónimo. No pai, fecha-se a ponta de escrita do pipe. O pai espera que o filho termine com um \texttt(wait) e verifica o código de saída do filho. Se este não indicar nenhum erro, o conteúdo do pipe é lido para um buffer que foi alocado dinamicamente e o endereço desse buffer é devolvido.

\subsubsection{ zipFile(char * filepath, char * newFile, int opcao) - função auxiliar}

Dados dois caminhos absolutos, indicados no título como filepath e newFile, esta função faz zip/unzip do ficheiro especificado em filepath e coloca o resultado no caminho indicado por newFile, dependendo do valor \texttt{opcao}. Os valores possíveis do argumento \texttt{opcao} são \texttt{ZIP} e \texttt{UNZIP}. Quando é invocada, esta função cria um pipe anónimo e depois faz \texttt{fork}. O filho redireciona o \texttt{stdout} para a ponta de escrita do pipe e depois faz um \texttt{exec} para executar o \texttt{gzip} com a opção \texttt{-c} para imprimir o resultado da compressão no \texttt{stdout}. O processo pai entra num loop de leitura do contúdo do pipe e escrita no ficheiro pretendido. Quando o processo filho terminar e o fifo ``esvaziar'', o pai sai do loop e a função termina.

\subsubsection{ temLink(char * filepath) - função auxiliar}
Dado um caminho absoluto para um ficheiro, esta função devolve 1 se existe um link para esse ficheiro na pasta \texttt{metadata} e 0 caso contrário. Esta verificação é feita percorrendo os links da pasta \texttt{metadata} e se a expansão do caminho apontado por um link (através da \texttt{readlink}) resultar num caminho igual ao que é passado como argumento, então encontramos um link para esse ficheiro e devolvemos 1. Se nenhum link na pasta verificar esta condição, devolvemos 0;

\section{Melhorias possíveis}

Com o avançar do projeto apercebemo-nos que seria melhor implementar no processo ``principal'' do \texttt{sobusrv} 
(aquele que é responsável por criar processos que executam comandos) um gestor de ficheiros abertos que consistiria num buffer de de strings com o nome dos ficheiros abertos nos processos filho de forma a evitar operações simultâneas sobre o mesmo ficheiro. Desta forma, tiravamos a responsabilidade aos utilizadores de não executar comandos que acedam aos mesmos ficheiros em simultâneo.

No entanto, tal operação exigia uma reestrururação relativamente extensa do programa do servidor e tal seria impraticável na fase avançada de desenvolvimento em que nos encontravamos.

\section{Conclusão}

Neste trabalho deparámo-nos com vários problemas que assolam o desenvolvimento de sistemas operativos, principalmente aqueles que estão ligados à sincronização e partilha de recursos. 

Tivemos de ser capazes de superar estes problemas utilizando a interface de \texttt{syscalls} e, desta forma, aprofundamos o nosso conhecimento de como vários pormenores dos sistemas operativos estão implementados. 

Em suma, consideramos que fizemos um bom trabalho, tendo implementado não só as funcionalidades básicas que nos foram pedidas mas também algumas funcionalidades mais avançadas que constam na secção de valorização.

\end{document}